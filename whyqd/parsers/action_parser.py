from __future__ import annotations
from typing import Dict, List, Union, Optional, Type, Any, TYPE_CHECKING
from uuid import uuid4

from . import CoreScript, ParserScript
from ..action import default_actions
from ..models import ConstraintsModel, FieldModel

if TYPE_CHECKING:
    from ..models import ColumnModel, SchemaActionModel, ModifierModel, CategoryActionModel, CategoryModel
    from ..schema import Schema
    from ..base import BaseSchemaAction
    import pandas as pd


class ActionScript:
    """Parsing functions for action scripts.

    Can process and validate any action script. Scripts may be recursive and are of the form:

        "ACTION > 'destination column' < [modifier 'source column', {action script}]"

    Modifiers are dependent on the specific Action, and destination columns are optional. Destinations should be
    explicit in the case of Schema destinations.

    Parameters
    ----------
    source_columns: list of ColumnModel
        Source columns upon which the script will be applied.
    schema: Schema
        Destination Schema
    """

    def __init__(self, source_columns: List[ColumnModel], schema: Schema) -> None:
        self.core = CoreScript()
        self.parser = ParserScript()
        self.source_columns = source_columns
        self.schema = schema
        self.source_modifiers = {}
        self.modifier_names = set()

    ###################################################################################################
    ### PARSE TRANSFORM SCRIPT
    ###################################################################################################

    def parse(self, script: str) -> Dict[str, Union[SchemaActionModel, List[ColumnModel], dict]]:
        """Generate the parsed dictionary of an initialised action script.

        Parameters
        ----------
        script: str
            An action script.

        Raises
        ------
        ValueError for invalid ACTIONs.

        Returns
        -------
        dict
            Parsed dictionary of an initialised action script.
        """
        # Script of form: "ACTION1 > 'destination' < [+ 'column2' + ACTION2 < ['column3', ACTION3 < ['column5', 'column6']]]"
        normalised_script = self._get_normalised_script(script)
        # Process first part
        root = self.parser.get_split_terms(normalised_script, "<")
        # There must always be a first term and it must always be an ACTION. Everything else is optional.
        split_terms = self.parser.get_split_terms(root[0], ">")
        action = self.parser.get_action_model(split_terms[0])
        if not action:
            raise ValueError(f"Action ({split_terms[0]}) is not recognised.")
        destination = None
        if len(split_terms) == 2:
            destination = self.parser.get_literal(split_terms[1])
            # Check if 'destination' is a column or schema field
            destination = self.parser.get_field_from_script(destination, self.source_columns, self.schema)
            is_field = isinstance(destination, FieldModel)
        source = None
        if len(root) > 1:
            source = "<".join(root[1:])
        # Process initial response
        if action.name == "NEW" and Any in action.structure:
            # Special case where value is assigned as default to 'destination' field
            if not is_field:
                raise ValueError(
                    f"'New' actions must have a schema field as the 'destination' term ({destination.name})."
                )
            value = self.parser.get_literal(root[1])
            if len(value) > 1:
                raise ValueError(f"'New' actions must only contain a single value term. ({root[1:]})")
            destination.constraints = ConstraintsModel(**{"default": {"name": value[0]}})
            return {"action": action, "destination": destination}
        if not source:
            if action.structure:
                # The structure for this action requires a source term
                raise ValueError(f"{action.name} action requires a source term ({action.structure}) but none found.")
            return {"action": action, "destination": destination}
        # If action does not include a structure, then no source term should be included
        if not action.structure:
            # The structure for this action requires a source term
            raise ValueError(f"{action.name} action does not include a source term but one found ({source}).")
        # Source exists *and* and is required, process the second part
        # Nested sources must not have destinations as these will be autogenerated
        last_i = None
        parsed = []
        for i, stack in list(self.parser.generate_contents(source)):
            # Generate contents yields the deepest, right-most nested bracket first, and goes from there.
            if not last_i:
                last_i = i
            if last_i == i:
                # Process nested sources on same level, e.g. [[nested_source1], [nested_source2]]
                parsed.append((stack, {"action": None, "source": self.parser.get_listed_literal(stack)}, uuid4().hex))
            else:
                # Structure: ACTION < SOURCE
                # Process: as pop 'up' through nested sources, replace lower levels with hash key to simplify
                # extraction of the action, then replace the hash with a nested dictionary {action: , source: }
                # where each 'source' contains the input for that action, and is the input for the higher level.
                parsed_stack = stack
                for (txt, prsed, hx) in parsed:
                    # replace the txt with hx
                    parsed_stack = parsed_stack.replace(f"[{txt}]", hx)
                i_prsed = []
                for s in self.parser.get_split_terms(parsed_stack, ","):
                    splt = self.parser.get_split_terms(s, "<")
                    if len(splt) == 1:
                        i_prsed.extend(self.parser.get_listed_literal(s))
                    else:
                        for (txt, prsed, hx) in parsed:
                            if hx in s:
                                prsed["action"] = self.parser.get_action_model(splt[0])
                                if not isinstance(prsed["action"], SchemaActionModel):
                                    raise ValueError(f"Only ACTIONS of Type `SchemaAction` can be nested ({stack}).")
                                i_prsed.append(prsed)
                parsed = [(stack, {"action": None, "source": i_prsed}, uuid4().hex)]
        # Once the stack is empty, need only the prsed 'source' section of the list
        source = [p[1]["source"] for p in parsed]
        source = self._get_recovered_source_columns(source)[0]
        parsed = {"action": action, "destination": destination, "source": source}
        self._check_validates(parsed)
        return parsed

    ###################################################################################################
    ### IMPLEMENT VALIDATED SCRIPT
    ###################################################################################################

    def transform(
        self,
        df: pd.DataFrame,
        action: SchemaActionModel,
        destination: FieldModel,
        source: Optional[list[Union[ModifierModel, ColumnModel, dict]]] = None,
        assigned: Optional[
            List[Dict[str, Union[CategoryActionModel, FieldModel, CategoryModel, ColumnModel, List[CategoryModel]]]]
        ] = None,
    ) -> pd.DataFrame:
        """
        A recursive transformation. A method should be a list fields upon which actions are applied, but
        each field may have nested sub-fields requiring their own actions. Before the action on the
        current field can be completed, it is necessary to perform the actions on each sub-field.

        Parameters
        ----------
        df: DataFrame
            Working data to be transformed
        action: SchemaActionModel
        destination: FieldModel
        source: list of ModifierModel, ColumnModel, and dicts of nested transforms, default None
        assigned: list of dict
            Specific to CATEGORISE actions. Each dict has values for: Assignment ACTION, destination schema field,
            schema category, source data column, and a list of source data column category terms assigned to that
            schema category.

        Returns
        -------
        Dataframe
            Containing the implementation of all nested transformations
        """
        action: Type[BaseSchemaAction]
        action = self.parser.get_action_class(action)()
        if not source:
            return action.transform(df, destination)
        flattened_source = []
        for term in source:
            if isinstance(term, dict):
                # Nested transform
                nested_destination = term.get("destination")
                if not nested_destination:
                    # Need to create a temporary column ... the action will be performed here
                    # then this nested structure will be replaced by the output of this new column
                    # Temporary column is based on initial root FieldModel destination to ensure
                    # all schema parameters carried over.
                    nested_destination = destination.copy()
                    nested_destination.name = f"nested_{uuid4().hex}"
                if term["action"].name == "CATEGORISE" and term.get("assigned"):
                    df = self.transform(
                        df, term["action"], nested_destination, term.get("source"), term.get("assigned")
                    )
                else:
                    df = self.transform(df, term["action"], nested_destination, term.get("source"))
                flattened_source.append(nested_destination)
            else:
                flattened_source.append(term)
        # Action transform
        if action.name == "CATEGORISE" and assigned:
            return action.transform(df, destination, flattened_source, assigned)
        else:
            return action.transform(df, destination, flattened_source)

    ###################################################################################################
    ### SUPPORT UTILITIES
    ###################################################################################################

    def _get_modifier(self, name: str) -> ColumnModel:
        # It is statistically almost impossible to have a column name that matches a randomly-generated UUID
        # Can be used to recover column from hex
        return next((c for c in self.source_columns if c.name == name or c.uuid.hex == name), None)

    def _get_normalised_script(self, script: str) -> str:
        """Replace all column names in a script by their hex uuid.

        'Normalises' a script so that any fruity column names don't cause parsing havoc.

        Parameters
        ----------
        script: str
            An action script.

        Returns
        -------
        str
        """
        normalised_script = self.parser.get_normalised_script(script, self.source_columns)
        self.modifier_names = set()
        self.source_modifiers = {}
        for action in default_actions:
            if action.name in normalised_script:
                action_modifiers = {}
                if action.modifiers:
                    # TODO: this isn't right ... modifiers may share a name but have different functions/descriptions
                    action_modifiers = {m.name: m for m in action.modifiers}
                for m in set(action_modifiers.keys()).difference(self.modifier_names):
                    # Preserve original Modifiers
                    self.source_modifiers[m] = action_modifiers[m]
                    normalised_script = normalised_script.replace(m, f",{m},")
                self.modifier_names.update(set(action_modifiers.keys()))
        return ",".join([s.strip() for s in normalised_script.split(",") if s.strip()])

    def _get_recovered_source_columns(self, source: Union(list, dict)) -> list:
        """Recovered hexed columns and modifiers from parsed script."""
        recovered_source = []
        if isinstance(source, dict):
            source = [source]
        for term in source:
            recovered = None
            if isinstance(term, str) and term in self.modifier_names:
                recovered = self.source_modifiers[term]
            elif isinstance(term, str):
                recovered = self.parser.get_field_from_script(term, self.source_columns, self.schema)
            elif isinstance(term, list):
                recovered = self._get_recovered_source_columns(term)
            elif isinstance(term, dict):
                # Check if 'destination' is a column or schema field
                destination = term.get("destination")
                if destination:
                    destination = self.parser.get_field_from_script(destination, self.source_columns, self.schema)
                recovered = {
                    "action": term.get("action"),
                    "destination": destination,
                    "source": self._get_recovered_source_columns(term.get("source")),
                }
            if not recovered:
                raise ValueError(f"Term ({term}) cannot be parsed.")
            recovered_source.append(recovered)
        return recovered_source

    def _check_validates(self, source: Union(list, dict)) -> bool:
        """Validate that each source conforms to the ACTION structure."""
        validates = False
        if not isinstance(source, dict):
            raise ValueError(f"Action script does not conform to required structure. ({source})")
        # [ColumnModel if s == "field" else ModifierModel for s in source["action"].structure]
        structure = source["action"].structure
        for source_strut in self.core.chunks(source["source"], len(structure)):
            for i, strut in enumerate(structure):
                if isinstance(source_strut[i], strut):
                    validates = True
                elif isinstance(source_strut[i], dict):
                    # Nested source
                    validates = self._check_validates(source_strut[i])
                else:
                    raise ValueError(
                        f"Action structure ({source_strut}) doesn't conform to ACTION structure requirements ({source['action'].structure})."
                    )
        return validates
